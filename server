#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import socket
import os
import thread
import time
import ast
import logging

if not len(sys.argv) == 3:
	print "Usage : server [id] [master_port]"
	sys.exit()

SERVER_PORT_BASE = 20000
CLIENT_PORT_BASE = SERVER_PORT_BASE
INT_MAX = sys.maxint

pid = int(sys.argv[1]) # id to start server
master_port = int(sys.argv[2])

logging.basicConfig(format='[' + str(pid) + '] %(levelname)s: %(message)s', level=logging.ERROR)

socks = {} # {pid : connection}
close_flag = {} # {pid : whether to close connection after this current anti-entropy}

'''Bayou Protocol Variables'''

pname = None # obtain this by recursive naming protocol

#connected_server = {} # pid : pname, connected servers

write_log = [] # list of logEntry, tentative and committed
# committed_log = [] # list of logEntry, committed

accept_time = 0

version_vector = {} # pname : max(accept_time)

play_list = {} # {song_name : {url:str, nwrites : int}}

primary = False

retirement = False

CSN = 0

class logEntry:
    def __init__(self, csn, accept_t, pn, cmd):
        global primary, CSN
        if primary:
            self.csn = CSN + 1
            CSN = CSN + 1
        else:
            self.csn = csn
        self.accept_t = accept_t
        self.pn = pn
        self.cmd = cmd
        values = cmd.split()
        self.type = values[0]
        self.interal_id = None
        self.song_name = None
        self.url = None
        if values[0] == 'CREATE' or values[0] == 'RETIRE':
            self.interal_id = values[1]
        elif values[0] == 'PUT':
            self.song_name = values[1]
            self.url = values[2]
        elif values[0] == 'DELETE':
            self.song_name = values[1]
        # whenever a new log is created, process it
        self.process_log()

    def __cmp__(self, other):
        if self.csn < other.csn:
            return -1
        elif self.csn > other.csn:
            return 1
        else:
            if self.accept_t < other.accept_t:
                return -1
            elif self.accept_t > other.accept_t:
                return 1
            else:
                if self.pn < other.pn:
                    return -1
                elif self.pn > other.pn:
                    return 1
                else:
                    return 0

    def process_log(self):
        global play_list, version_vector, retirement
        if self.type == 'CREATE':
            version_vector[self.interal_id] = self.accept_t
        elif self.type == 'RETIRE':
            if not retirement:
                version_vector.pop(self.interal_id)
        elif self.type == 'PUT':
            if version_vector[self.interal_id] < self.accept_t:
                version_vector[self.interal_id] = self.accept_t
            if song_name not in play_list:
                play_list[self.song_name] = {'url' : self.url, 'nwrites' : 1}
            else:
                play_list[self.song_name]['url'] = self.url
                play_list[self.song_name]['nwrites'] = play_list[self.song_name]['nwrites'] + 1
        elif self.type == 'DELETE':
            if version_vector[self.interal_id] < self.accept_t:
                version_vector[self.interal_id] = self.accept_t
            if song_name in play_list:
                play_list.pop(self.song_name)

def master_handler(master_sock):
    global socks, close_flag, accept_time, pname, retirement, write_log
	while True:
        try:
            data = master_sock.recv(256)
        except:
            data = None
        if data:
            logging.debug("data received from master: " + data)
            for line in data.split('\n'):
                if not line:
                    break
                s = line.split()
                if s[0] == 'createConn':
                    for i in range(1, len(s)):
                        server_id = int(s[i])
                        if server_id not in socks:
                            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                            sock.bind(('localhost', SERVER_PORT_BASE + pid))

                            status = sock.connect_ex(('localhost', SERVER_PORT_BASE + server_id))
                            if status != 0:
                                logging.debug('connection to server failed: ' + server_id)
                                continue
                            socks[server_id] = sock
                            close_flag[server_id] = False
                            if pname == None:
                                # The case when a process does not have a name
                                # assume the other process already has a name
                                sock.sendall('create\n')
                                name_resp = sock.recv(256)
                                name_resp = name_resp.split('\n')[0].split()
                                accept_time = int(name_resp[0]) + 1
                                pname = '%s|%d' % (name_resp[1], int(name_resp[0]))
                            else:
                                sock.sendall('establish\n')
                                name_resp = sock.recv(256)
                                name_resp = name_resp.split.('\n')[0].split()
                                if name_resp[0] == 'create':
                                    write_log.append(logEntry(INT_MAX, accept_time, pname, 'CREATE %s|%d' % (pname, accept_time)))
                                    accept_time = accept_time + 1
                                    sock.sendall('%d %s\n' % (accept_time, pname))
                                # the other case : peer has name, so directly enter AE
                            thread.start_new_thread(anti_entropy, (sock, server_id))
                elif s[0] == 'breakConn':
                    for i in range(1, len(s)):
                        server_id = int(s[i])
                        if server_id in socks:
                            close_flag[server_id] = True
                elif s[0] == 'retire':
                    write_log.append(logEntry(INT_MAX, accept_time, pname, 'RETIRE %s' % pname))
                    accept_time = accept_time + 1
                    retirement = True
                elif s[0] == 'printLog':
                    all_log = 'log '
                    for log_entry in write_log:
                        if log_entry.csn == INT_MAX:
                            stable_bool = 'FALSE'
                        else:
                            stable_bool = 'TRUE'
                        if log_entry.type == 'PUT':
                            all_log = all_log + ',%s:(%s,%s):%s' % (log_entry.type, log_entry.song_name, log_entry.url, stable_bool)
                        elif log_entry.type == 'DELETE':
                            all_log = all_log + ',%s:(%s):%s' % (log_entry.type, log_entry.song_name, stable_bool)
                        elif log_entry.type == 'CREATE':
                            all_log = all_log + ',%s:(%s):%s' % (log_entry.type, log_entry.interal_id, stable_bool)
                        elif log_entry.type == 'RETIRE':
                            all_log = all_log + ',%s:(%s):%s' % (log_entry.type, log_entry.interal_id, stable_bool)
                    all_log = all_log + '\n'
                    master_sock.sendall(all_log)
        else:
            logging.info('connection from master closed')
            break
    master_sock.close()
    logging.info('process %d exits', pid)
    os._exit(1)

def server_handler(server_sock, server_id):
    global pname, accept_time, write_log, play_list
    active_flag = True
    while active_flag:
        try:
            data = server_sock.recv(256)
        except:
            data = None
        if data:
            logging.debug("data received from peers: " + data)
            for line in data.split('\n'):
                if not line:
                    break
                s = line.split()
                # cases when peer is client
                if s[0] == 'add':
                    client_write_times = int(s[1])
                    songName = s[2]
                    url = s[3]
                    if songName not in play_list:
                        play_list[songName] = {'url' : None, 'nwrites' : 0}
                    if play_list[songName]['nwrites'] >= client_write_times - 1:
                        server_sock.sendall('ack\n')
                        write_log.append(logEntry(INT_MAX, accept_time, pname, 'PUT %s %s' % (s[2], s[3])))
                        accept_time = accept_time + 1
                    else:
                        # write fails
                        server_sock.sendall('failed\n')
                    accept_time = accept_time + 1
                elif s[0] == 'delete':
                    client_write_times = int(s[1])
                    songName = s[2]
                    if songName not in play_list:
                        play_list[songName] = {'url' : None, 'nwrites' : 0}
                    if play_list[songName]['nwrites'] >= client_write_times - 1:
                        server_sock.sendall('ack\n')
                        write_log.append(logEntry(INT_MAX, accept_time, pname, 'DELETE %s' % s[2]))
                        accept_time = accept_time + 1
                    else:
                        # write fails
                        server_sock.sendall('failed\n')
                    accept_time = accept_time + 1
                elif s[0] == 'get':
                    client_write_times = int(s[1])
                    songName = s[2]
                    return_msg = None
                    if songName not in play_list:
                        return_msg = 'ERR_KEY\n'
                    elif play_list[songName]['nwrites'] >= client_write_times:
                        return_msg = play_list[songName]['url'] + '\n'
                    else:
                        # read fails, error dependency
                        return_msg = 'ERR_DEP\n'
                    server_sock.sendall(return_msg)

                # cases when peer is server
                elif s[0] == 'create':
                    # new pname : 'pname|accept_time'
                    write_log.append(logEntry(INT_MAX, accept_time, pname, 'CREATE %s|%d' % (pname, accept_time)))
                    accept_time = accept_time + 1
                    server_sock.sendall('%d %s\n' % (accept_time, pname))
                    anti_entropy(server_sock, server_id)
                    active_flag = False
                    break
                elif s[0] == 'establish':
                    if pname == None:
                        server_sock.sendall('create\n')
                        name_resp = server_sock.recv(256)
                        name_resp = name_resp.split('\n')[0].split()
                        accept_time = int(name_resp[0]) + 1
                        pname = '%s|%d' % (name_resp[1], int(name_resp[0]))
                    else:
                        server_sock.sendall('ack\n')
                    anti_entropy(server_sock, server_id)
                    active_flag = False
                    break
                # other cases will be handled in anti-entropy
        else:
            logging.info('connection from master closed')
            break
    server_sock.close()
    logging.info('process %d loses connection from %d', pid, server_id)

def anti_entropy(server_sock, server_id):
    global close_flag, retirement, CSN, write_log, pname, version_vector, primary
    while not close_flag[server_id]:
        # keep synchronized and wait for a while before a new AE
        time.sleep(0.05)
        server_sock.sendall('csn %d %s\n' % (CSN, str(version_vector)))
        response = server_sock.recv(512)
        response = response.split('\n')[0].split()
        if response[0] == 'csn':
            other_csn = int(response[1])
            other_vv = ast.literal_eval(response[2])

            for log in write_log:
                if log.pn in other_vv:
                    if log.csn != INT_MAX:
                        # committed log
                        if CSN > other_csn:
                            if log.accept_t <= other_vv[log.pn]:
                                server_sock.sendall('commit %d %s %d\n' % (log.accept_t, log.pn, log.csn))
                            else:
                                server_sock.sendall('write %d %s %d %s\n' % (log.accept_t, log.pn, log.csn, log.cmd))
                    else:
                        # tentative log
                        if log.accept_t > other_vv[log.pn]:
                            server_sock.sendall('write %d %s %d %s\n' % (log.accept_t, log.pn, log.csn, log.cmd))
                else:
                    # Missing vv case
                    recursive_time_stamp = log.pn[log.pn.rfind('|') + 1 : ]
                    recursive_name = log.pn[0 : log.pn.rfind('|')]
                    if other_vv[recursive_name] < recursive_time_stamp:
                        server_sock.sendall('write %d %s %d %s\n' % (log.accept_t, log.pn, log.csn, log.cmd))
            if primary and retirement:
                server_sock.sendall('primary\n')
            server_sock.sendall('end\n')
            ae_end_flag = False
            while not ae_end_flag:
                response = server_sock.recv(256)
                response = response.split('\n')
                for msg in response:
                    words = msg.split()
                    if words[0] == 'commit':
                        new_accept_t = int(words[1])
                        new_pn = words[2]
                        new_csn = int(words[3])
                        for ii in len(write_log):
                            if write_log[ii].accept_t == new_accept_t and write_log[ii].pn == new_pn:
                                write_log[ii].csn = new_csn
                                break
                    elif words[0] == 'write':
                        new_accept_t = int(words[1])
                        new_pn = words[2]
                        new_csn = int(words[3])
                        new_cmd = words[4]
                        write_log.append(logEntry(new_csn, new_accept_t, new_pn, new_cmd))
                    elif words[0] == 'primary':
                        primary = True
                    elif words[0] == 'end':
                        ae_end_flag = True
                        break

            if other_csn > CSN:
                CSN = other_csn
            if retirement:
                break
    server_sock.close()
    logging.info('process %d loses connection from %d', pid, server_id)
    if retirement:
        os._exit(1)

#create socket for master
sock_to_master = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock_to_master.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock_to_master.bind(('localhost', master_port))
sock_to_master.listen(1)

#create socket for other servers and clients
sock_to_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock_to_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock_to_server.bind(('localhost', SERVER_PORT_BASE + pid))
sock_to_server.listen(1)

if pid == 0:
    primary = True
    pname = '0'
    accept_time = 0

# start responding to master
master_sock, _ = sock_to_master.accept()
# start new thread to handle master connection
thread.start_new_thread(master_handler, (master_sock,))

while True:
    server_sock, server_addr = sock_to_server.accept()
    server_id = int(server_addr[1]) - SERVER_PORT_BASE
    thread.start_new_thread(server_handler, (server_sock, server_id))